import math
import requests
import streamlit as st
import os

# Функция для расчёта расстояния между двумя точками (Haversine)
def haversine(lat1, lon1, lat2, lon2):
    R = 6371.0
    lat1_rad = math.radians(lat1)
    lon1_rad = math.radians(lon1)
    lat2_rad = math.radians(lat2)
    lon2_rad = math.radians(lon2)
    
    dlat = lat2_rad - lat1_rad
    dlon = lon2_rad - lon1_rad
    
    a = math.sin(dlat / 2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    
    distance = R * c
    return distance

# Функция для проверки, внутри ли точка полигона (ray-casting)
def is_inside_polygon(point, polygon):
    if not polygon:
        raise ValueError("Полигон не загружен")
    x, y = point[0], point[1]  # lon, lat
    n = len(polygon)
    inside = False
    p1x, p1y = polygon[0]
    for i in range(n + 1):
        p2x, p2y = polygon[i % n]
        if y > min(p1y, p2y):
            if y <= max(p1y, p2y):
                if x <= max(p1x, p2x):
                    if p1y != p2y:
                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                    if p1x == p2x or x <= xinters:
                        inside = not inside
        p1x, p1y = p2x, p2y
    return inside

# Расстояние от точки до сегмента (a-b)
def distance_to_segment(p, a, b):
    px, py = p
    ax, ay = a
    bx, by = b
    abx = bx - ax
    aby = by - ay
    apx = px - ax
    apy = py - ay
    proj = apx * abx + apy * aby
    len_sq = abx * abx + aby * aby
    if len_sq == 0:
        return haversine(py, px, ay, ax)
    t = max(0, min(1, proj / len_sq))
    cx = ax + t * abx
    cy = ay + t * aby
    return haversine(py, px, cy, cx)

# Расчёт минимального расстояния до полигона
def distance_to_polygon(point, polygon):
    if not polygon:
        raise ValueError("Полигон не загружен")
    min_dist = float('inf')
    n = len(polygon)
    for i in range(n):
        a = polygon[i]
        b = polygon[(i + 1) % n]
        dist = distance_to_segment(point, a, b)
        if dist < min_dist:
            min_dist = dist
    return min_dist

# Загрузка полигона Твери с OpenStreetMap (если доступен)
def load_tver_polygon():
    url = "http://polygons.openstreetmap.fr/get_geojson.py?id=77760&params=0"
    try:
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            data = response.json()
            if data['type'] == 'MultiPolygon':
                polygon = data['coordinates'][0][0]
            elif data['type'] == 'Polygon':
                polygon = data['coordinates'][0]
            else:
                raise ValueError("Неподдерживаемый тип GeoJSON")
            polygon = [(lon, lat) for lon, lat in polygon]
            # Замыкаем полигон
            if polygon[0] != polygon[-1]:
                polygon.append(polygon[0])
            return polygon
        else:
            raise ValueError(f"Ошибка HTTP: {response.status_code}")
    except Exception as e:
        st.warning(f"Не удалось загрузить полигон Твери: {e}. Используется запасной полигон из GeoJSON.")
        return fallback_tver_polygon()

# Запасной полигон из geoBoundaries-RUS-ADM2.geojson (основной, ~200 точек, замкнутый)
def fallback_tver_polygon():
    polygon = [
        (35.7214173, 56.8359387), (35.7223742, 56.8351317), (35.7276293, 56.8353822), (35.7239737, 56.8260607),
        (35.7273012, 56.8253055), (35.7309988, 56.819144), (35.7433418, 56.8160917), (35.7588178, 56.8164557),
        (35.7599731, 56.8171937), (35.7619663, 56.8177314), (35.763873, 56.8189298), (35.7678352, 56.8217582),
        (35.773856, 56.8233021), (35.7758327, 56.8235829), (35.7868702, 56.8252386), (35.7977995, 56.8282764),
        (35.7999486, 56.8323838), (35.8052696, 56.8316662), (35.8117308, 56.8307156), (35.8129557, 56.8303302),
        (35.8193553, 56.8295261), (35.8233666, 56.8294789), (35.8303531, 56.8283262), (35.831133, 56.8282091),
        (35.8280096, 56.8260311), (35.826118, 56.8259575), (35.8248298, 56.8262685), (35.8243216, 56.8260528),
        (35.8241256, 56.8256715), (35.8241371, 56.8249753), (35.8287864, 56.8228744), (35.8329633, 56.8203385),
        (35.8386762, 56.8268619), (35.8415245, 56.8266067), (35.8421752, 56.8262297), (35.8442061, 56.8259643),
        (35.851094, 56.8252283), (35.851157, 56.8252005), (35.856974, 56.8226361), (35.8584806, 56.8226901),
        (35.8609421, 56.8215328), (35.8730699, 56.8202006), (35.8720684, 56.8192339), (35.8723849, 56.816632),
        (35.8741353, 56.8144366), (35.8743899, 56.8132799), (35.8719347, 56.8083659), (35.8816434, 56.800959),
        (35.8903639, 56.7935362), (35.8999643, 56.79374), (35.9101817, 56.7971027), (35.9093186, 56.8001615),
        (35.9205758, 56.8027169), (35.9210333, 56.8023348), (35.9211974, 56.8018578), (35.9215715, 56.8017174),
        (35.925336, 56.8008293), (35.926864, 56.799932), (35.9291224, 56.7976773), (35.9349781, 56.7992755),
        (35.9353758, 56.7993841), (35.9493267, 56.7997087), (35.9585022, 56.8023738), (35.9544355, 56.8050883),
        (35.9548724, 56.8067312), (35.9573686, 56.8091984), (35.9946754, 56.7947333), (36.0005297, 56.7923721),
        (36.0053254, 56.7900422), (36.010038, 56.7871053), (36.0116681, 56.7851689), (36.0141254, 56.7833245),
        (36.0437014, 56.7837801), (36.046953, 56.788493), (36.0515683, 56.7914742), (36.0555403, 56.7957173),
        (36.0465038, 56.7983925), (36.0471709, 56.7999623), (36.0483248, 56.800649), (36.0498074, 56.8026931),
        (36.0350793, 56.8061452), (36.0359337, 56.8072856), (36.0273756, 56.8097066), (36.0181221, 56.8112173),
        (36.0127919, 56.8121098), (36.0085905, 56.813397), (36.00518, 56.8148941), (35.9978753, 56.8194496),
        (36.0035986, 56.8222608), (36.0055202, 56.821905), (36.0067147, 56.822915), (36.0039543, 56.8260847),
        (36.0073963, 56.8255899), (36.0039266, 56.8310474), (36.0109999, 56.8395724), (36.0106829, 56.8403197),
        (36.0104207, 56.8443724), (36.0175702, 56.8489305), (36.0209429, 56.8510805), (36.0221548, 56.851853),
        (36.016904, 56.8544385), (36.0141975, 56.8551618), (36.0062066, 56.8562181), (36.0043062, 56.8566558),
        (36.0005591, 56.858369), (35.9934602, 56.8615278), (35.9934652, 56.8617218), (35.9934887, 56.8626239),
        (35.998932, 56.8663628), (36.0006122, 56.8687334), (36.0022826, 56.8710722), (35.9999815, 56.8733578),
        (35.9906489, 56.8782306), (35.9876333, 56.8780643), (35.9865086, 56.8785704), (35.9846891, 56.8787873),
        (35.9829358, 55.879185), (35.981312, 56.8792841), (35.9669415, 56.8896158), (35.9675196, 56.8898633),
        (35.9666388, 56.8904184), (35.9659613, 56.8904184), (35.964149, 56.8916212), (35.9645894, 56.8925926),
        (35.9627424, 56.8935121), (35.9587687, 56.8935841), (35.9462309, 56.8954271), (35.9444141, 56.8959219),
        (35.942162, 56.8986972), (35.9388636, 56.9010101), (35.9319068, 56.903069), (35.9293276, 56.9032585),
        (35.9279798, 56.8964301), (35.9279749, 56.8963348), (35.9289329, 56.8957111), (35.9294469, 56.8929011),
        (35.928301, 56.8928975), (35.9282648, 56.8922528), (35.9282136, 56.8913428), (35.9265728, 56.8895936),
        (35.923527, 56.88768), (35.9230795, 56.8893623), (35.9218091, 56.8893189), (35.9207505, 56.8921379),
        (35.9214122, 56.8922246), (35.9211211, 56.8939159), (35.9211631, 56.8956671), (35.9221267, 56.8970669),
        (35.9226209, 56.8981639), (35.9232647, 56.8996974), (35.9230243, 56.9014646), (35.9206857, 56.9042586),
        (35.9185534, 56.9066789), (35.9176113, 56.9084199), (35.9185637, 56.9122587), (35.9168632, 56.914172),
        (35.9159339, 56.9152452), (35.9152229, 56.916327), (35.9147454, 56.9193626), (35.9142853, 56.9200495),
        (35.9117514, 56.9216734), (35.9109759, 56.9225324), (35.9108522, 56.9240261), (35.9103121, 56.9252667),
        (35.9095044, 56.9264159), (35.9069881, 56.9302809), (35.9061952, 56.9312118), (35.9011321, 56.9360617),
        (35.8960346, 56.9349879), (35.9019003, 56.9290494), (35.9005519, 56.9286635), (35.8995356, 56.9289985),
        (35.8980748, 56.9286982), (35.8959839, 56.9292454), (35.8950597, 56.9294873), (35.8962183, 56.9263602),
        (35.8921818, 56.9263917), (35.8920123, 56.9254656), (35.8828612, 56.9252408), (35.8827409, 56.9192711),
        (35.8787038, 56.9175679), (35.8742501, 56.916997), (35.8750318, 56.9159066), (35.8696174, 56.9136921),
        (35.8777285, 56.9068249), (35.8846959, 56.9076068), (35.8892643, 56.9019368), (35.8857049, 56.8934085),
        (35.8795653, 56.8943776), (35.8745527, 56.8984411), (35.8694779, 56.8963429), (35.8655471, 56.8985046),
        (35.8605667, 56.9009682), (35.8566194, 56.8987034), (35.8549407, 56.89666), (35.8540205, 56.8942826),
        (35.8436557, 56.9044966), (35.8348664, 56.9078804), (35.8302359, 56.9093905), (35.8249894, 56.9099907),
        (35.8153891, 56.9067268), (35.8145459, 56.906102), (35.8035337, 56.9024355), (35.8062807, 56.9002475),
        (35.8069569, 56.8996393), (35.8037346, 56.8992774), (35.801133, 56.8982852), (35.8048663, 56.8957952),
        (35.803913, 56.8952964), (35.8014452, 56.8938293), (35.7998623, 56.8949481), (35.7927137, 56.8929949),
        (35.7906534, 56.8950464), (35.789238, 56.8958195), (35.7878828, 56.8963293), (35.7868543, 56.8978407),
        (35.785023, 56.8975096), (35.7844641, 56.8977517), (35.7823582, 56.8967279), (35.7803446, 56.8926039),
        (35.7810009, 56.8919177), (35.7811859, 56.891345), (35.7855616, 56.8882923), (35.7851486, 56.8878075),
        (35.7919074, 56.8851564), (35.7929043, 56.8850952), (35.7932743, 56.8846487), (35.7946158, 56.8845897),
        (35.7970653, 56.8853234), (35.7963581, 56.8843707), (35.7980234, 56.8842107), (35.7972098, 56.881839),
        (35.8033221, 56.8809085), (35.8026276, 56.8805589), (35.8022113, 56.8800871), (35.802058, 56.8792876),
        (35.8029051, 56.8785875), (35.8057148, 56.8778724), (35.8024284, 56.8756002), (35.8016254, 56.8743915),
        (35.8016524, 56.8725828), (35.8002068, 56.8726978), (35.7991907, 56.8725425), (35.797416, 56.869108),
        (35.7968455, 56.8664617), (35.7962327, 56.8655916), (35.7942333, 56.8648549), (35.7938429, 56.8626864),
        (35.7943324, 56.8616765), (35.793937, 56.860606), (35.7922528, 56.8588774), (35.7915743, 56.8574747),
        (35.7895403, 56.8580384), (35.7896888, 56.8569763), (35.7904497, 56.8533665), (35.7893395, 56.8533665),
        (35.7891236, 56.853906), (35.7876622, 56.8536783), (35.781625, 56.8531529), (35.781625, 56.8526133),
        (35.777149, 56.8528009), (35.7769302, 56.8548944), (35.7679087, 56.8527845), (35.7662557, 56.8527452),
        (35.7658784, 56.8524112), (35.76497, 56.8524809), (35.7635182, 56.8514683), (35.7632393, 56.8503771),
        (35.7634056, 56.8499635), (35.7643604, 56.8499459), (35.7654386, 56.8500075), (35.7655298, 56.8495519),
        (35.7656854, 56.8481322), (35.7646158, 56.8479319), (35.7636899, 56.8478543), (35.7612564, 56.8474671),
        (35.7502307, 56.8446322), (35.7391718, 56.8407114), (35.7397198, 56.8394646), (35.7404116, 56.8384412),
        (35.7355213, 56.8371304), (35.7297909, 56.8365197), (35.7271892, 56.8371549), (35.7252607, 56.8371519),
        (35.7215606, 56.8365438), (35.7214173, 56.8359387), (35.7214173, 56.8359387)
    ]
    # Замыкаем полигон
    if polygon[0] != polygon[-1]:
        polygon.append(polygon[0])
    return polygon

# Тарифы
rate_per_km = 32
cargo_prices = {
    'маленький': 350,
    'средний': 500,
    'большой': 800
}

# Геокодирование адреса через Яндекс
def geocode_address(address, api_key):
    url = f"https://geocode-maps.yandex.ru/1.x/?apikey={api_key}&geocode={address}&format=json"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        try:
            pos = data['response']['GeoObjectCollection']['featureMember'][0]['GeoObject']['Point']['pos']
            lon, lat = map(float, pos.split(' '))
            return lat, lon
        except (IndexError, KeyError):
            raise ValueError("Адрес не найден. Уточните адрес (например, добавьте 'Тверь').")
    else:
        raise ValueError(f"Ошибка API: {response.status_code}")

# Расчёт стоимости
def calculate_delivery_cost(cargo_size, dest_lat, dest_lon):
    if cargo_size not in cargo_prices:
        raise ValueError("Неверный размер груза. Доступны: маленький, средний, большой")
    
    base_cost = cargo_prices[cargo_size]
    
    point = (dest_lon, dest_lat)
    if is_inside_polygon(point, tver_polygon):
        return base_cost
    else:
        dist_from_boundary = distance_to_polygon(point, tver_polygon)
        total_extra_distance = dist_from_boundary * 2
        extra_cost = total_extra_distance * rate_per_km
        return round(base_cost + extra_cost, 2)

# Загрузка полигона один раз при запуске
try:
    tver_polygon = load_tver_polygon()
except Exception as e:
    st.warning(f"Не удалось загрузить полигон Твери: {e}. Используется запасной полигон.")
    tver_polygon = fallback_tver_polygon()

# Режим админа для отладки
admin_password = st.text_input("Админ пароль для отладки (оставьте пустым для обычного режима)", type="password")
if admin_password == "admin123":  # Измените пароль на свой
    st.write(f"Количество точек в полигоне: {len(tver_polygon)}")
    st.write(f"Первая точка полигона: {tver_polygon[0]}")
    st.write(f"Последняя точка полигона: {tver_polygon[-1]} (должна совпадать с первой для замыкания)")

st.title("Калькулятор стоимости доставки по Твери")
st.write("Введите адрес доставки и выберите размер груза.")

api_key = os.environ.get("API_KEY")
if not api_key:
    st.error("Ошибка: API-ключ не настроен. Обратитесь к администратору.")
else:
    cargo_size = st.selectbox("Размер груза", ["маленький", "средний", "большой"])
    address = st.text_input("Адрес доставки (например, 'Тверь, ул. Советская, 10')")

    if st.button("Рассчитать"):
        if address:
            try:
                dest_lat, dest_lon = geocode_address(address, api_key)
                cost = calculate_delivery_cost(cargo_size, dest_lat, dest_lon)
                st.success(f"Стоимость доставки: {cost} руб.")
                if admin_password == "admin123":
                    point = (dest_lon, dest_lat)
                    inside = is_inside_polygon(point, tver_polygon)
                    st.write(f"Координаты адреса: lat={dest_lat}, lon={dest_lon}")
                    st.write(f"Адрес внутри границы: {inside}")
                    if not inside:
                        dist_from_boundary = distance_to_polygon(point, tver_polygon)
                        st.write(f"Расстояние до границы: {dist_from_boundary} км")
                        st.write(f"Доплата: {dist_from_boundary} × 2 × 32 = {dist_from_boundary * 2 * 32} руб.")
            except ValueError as e:
                st.error(f"Ошибка: {e}")
        else:
            st.warning("Введите адрес.")
</xaiArtifact>
